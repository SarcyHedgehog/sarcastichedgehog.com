<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Pongout3D</title>
  <style>
    html, body { margin: 0; overflow: hidden; background: #1e0e1e; }
    #overlay {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      font-family: sans-serif;
      color: white;
      font-size: 20px;
      z-index: 1;
    }
  </style>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js';
    import * as Multisynq from 'https://cdn.jsdelivr.net/npm/@multisynq/client@1/bundled/multisynq-client.esm.js';

    const C = { paddleSpeed: 0.1, ballSpeed: 0.05, winScore: 10 }; // Ball speed might need adjustment if game feels too fast/slow with new tick
    const MODEL_TICK_RATE_MS = 33; // Approx 30 FPS for game logic
    const BALL_RADIUS = 0.1;
    const BRICK_COLLISION_EPSILON = 0.001;
    const COURT_WIDTH = 8.0;
    const COURT_DEPTH = 5.0;

    // Paddle Dimensions
    const PADDLE_THICKNESS_X = 0.2;
    const PADDLE_VISUAL_HEIGHT_Y = 0.2;
    const PADDLE_LENGTH_Z = 1.2;

    // Paddle Positions (Model Coordinates)
    const PADDLE_VIEW_X_OFFSET_FROM_EDGE = 0.1;
    const PADDLE_MODEL_CENTER_X_ABS = COURT_WIDTH/2 - PADDLE_THICKNESS_X/2 - PADDLE_VIEW_X_OFFSET_FROM_EDGE;
    const PADDLE1_MODEL_CENTER_X = -PADDLE_MODEL_CENTER_X_ABS;
    const PADDLE2_MODEL_CENTER_X = PADDLE_MODEL_CENTER_X_ABS;
    const PADDLE1_INNER_EDGE_X = PADDLE1_MODEL_CENTER_X + PADDLE_THICKNESS_X / 2;
    const PADDLE2_INNER_EDGE_X = PADDLE2_MODEL_CENTER_X - PADDLE_THICKNESS_X / 2;

    // Brick Wall Structure ("Portrait" bricks)
    const WALL_BRICK_WIDTH = 0.25;         // X-dim (shorter side)
    const WALL_BRICK_DEPTH = 0.5;          // Y-dim (court depth axis - longer side, "portrait")
    const WALL_NUM_BRICK_SEGMENTS_WIDE = 5; // Number of bricks across X to form wall width
    const WALL_TOTAL_WIDTH = WALL_NUM_BRICK_SEGMENTS_WIDE * WALL_BRICK_WIDTH; // 5 * 0.25 = 1.25
    const WALL_NUM_ROWS_DEEP = Math.round(COURT_DEPTH / WALL_BRICK_DEPTH); // 5.0 / 0.5 = 10
    const BRICK_VISUAL_HEIGHT_Y = 0.2;


    class PongModel extends Multisynq.Model {
      init() {
        this.players = {};
        this.paddleY = { 1: 0, 2: 0 };
        this.ball = { x: 0, y: 0, vx: 0, vy: 0 };
        this.score = { 1: 0, 2: 0 };
        this.state = "waiting";
        this.countdown = 5;
        this.bricks = this.initBricks();
        this.lastStarter = 2;

        this.subscribe(this.sessionId, "view-join", this.onJoin);
        this.subscribe(this.sessionId, "view-exit", this.onLeave);
        this.subscribe(this.sessionId, "move", this.onMove);

        this.future(MODEL_TICK_RATE_MS).step(); // Faster model tick
      }

      initBricks() {
        const bricks = [];
        const startModelX = -(WALL_TOTAL_WIDTH / 2) + (WALL_BRICK_WIDTH / 2);
        const startModelY = (COURT_DEPTH / 2) - (WALL_BRICK_DEPTH / 2);

        for (let r = 0; r < WALL_NUM_ROWS_DEEP; r++) {
            const currentBrickRowModelY = startModelY - r * WALL_BRICK_DEPTH;
            for (let c = 0; c < WALL_NUM_BRICK_SEGMENTS_WIDE; c++) {
                bricks.push({
                    x: startModelX + c * WALL_BRICK_WIDTH,
                    y: currentBrickRowModelY,
                    width: WALL_BRICK_WIDTH,
                    depth: WALL_BRICK_DEPTH
                });
            }
        }
        return bricks;
      }

      onJoin({ viewId }) {
        if (Object.values(this.players).includes(viewId)) return;
        if (!this.players[1]) this.players[1] = viewId;
        else if (!this.players[2]) this.players[2] = viewId;
        if (Object.keys(this.players).length === 2 && this.state === "waiting") {
          this.startCountdown();
        }
        this.publish("ui", "state", this.snapshot());
      }

      onLeave({ viewId }) {
        const player = this.getPlayerNumber(viewId);
        if (!player) return;
        delete this.players[player];
        this.state = "disconnected";
        this.ball.vx = 0;
        this.ball.vy = 0;
        this.publish("ui", "state", this.snapshot());
      }

      onMove({ viewId, dy }) {
        const player = this.getPlayerNumber(viewId);
        if (player && this.state === "playing") {
          // Scale dy by tick rate if paddleSpeed was tuned for 50ms ticks
          // const effectiveDy = dy * (MODEL_TICK_RATE_MS / 50.0);
          // Or adjust C.paddleSpeed directly if preferred
          this.paddleY[player] += dy; // Assuming C.paddleSpeed is fine per animation frame interval
          const paddleHalfLength = PADDLE_LENGTH_Z / 2;
          const maxPaddleModelY = (COURT_DEPTH / 2) - paddleHalfLength;
          this.paddleY[player] = Math.max(-maxPaddleModelY, Math.min(maxPaddleModelY, this.paddleY[player]));
        }
      }

      getPlayerNumber(id) {
        return Object.entries(this.players).find(([, v]) => v === id)?.[0];
      }

      startCountdown() {
        this.countdown = 5;
        this.state = "countdown";
        this.future(1000).countdownTick(); // Countdown ticks are 1 second
      }

      countdownTick() {
        this.countdown--;
        if (this.countdown <= 0) {
          this.state = "playing";
          this.lastStarter = this.lastStarter === 1 ? 2 : 1;
          const servingPlayer = this.lastStarter;
          
          const dir = servingPlayer === 1 ? 1 : -1;
          const ballStartX = servingPlayer === 1 ? PADDLE1_INNER_EDGE_X + BALL_RADIUS + 0.05 : PADDLE2_INNER_EDGE_X - BALL_RADIUS - 0.05;
          const ballStartY = this.paddleY[servingPlayer];
          
          this.ball = { x: ballStartX, y: ballStartY, vx: dir * C.ballSpeed, vy: 0 };
        } else {
          this.future(1000).countdownTick();
        }
        this.publish("ui", "state", this.snapshot());
      }

      step() {
        if (this.state === "playing") {
          this.ball.x += this.ball.vx;
          this.ball.y += this.ball.vy;

          const courtHalfDepth = COURT_DEPTH / 2;
          if (this.ball.y + BALL_RADIUS > courtHalfDepth || this.ball.y - BALL_RADIUS < -courtHalfDepth) {
            this.ball.vy *= -1;
            this.ball.y = Math.max(-courtHalfDepth + BALL_RADIUS, Math.min(courtHalfDepth - BALL_RADIUS, this.ball.y));
          }

          const paddleLogicalHalfLength = PADDLE_LENGTH_Z / 2;
          
          if (this.ball.vx < 0 && this.ball.x - BALL_RADIUS < PADDLE1_INNER_EDGE_X && this.ball.x + BALL_RADIUS > PADDLE1_MODEL_CENTER_X - PADDLE_THICKNESS_X / 2 && Math.abs(this.ball.y - this.paddleY[1]) < (paddleLogicalHalfLength + BALL_RADIUS)) {
            this.ball.vx *= -1;
            this.ball.x = PADDLE1_INNER_EDGE_X + BALL_RADIUS + BRICK_COLLISION_EPSILON;
            this.ball.vy += (this.ball.y - this.paddleY[1]) * 0.15 * Math.abs(this.ball.vx) / C.ballSpeed;
            this.ball.vy = Math.max(-C.ballSpeed*2, Math.min(C.ballSpeed*2, this.ball.vy));
          }
          else if (this.ball.vx > 0 && this.ball.x + BALL_RADIUS > PADDLE2_INNER_EDGE_X && this.ball.x - BALL_RADIUS < PADDLE2_MODEL_CENTER_X + PADDLE_THICKNESS_X / 2 && Math.abs(this.ball.y - this.paddleY[2]) < (paddleLogicalHalfLength + BALL_RADIUS)) {
            this.ball.vx *= -1;
            this.ball.x = PADDLE2_INNER_EDGE_X - BALL_RADIUS - BRICK_COLLISION_EPSILON;
            this.ball.vy += (this.ball.y - this.paddleY[2]) * 0.15 * Math.abs(this.ball.vx) / C.ballSpeed;
            this.ball.vy = Math.max(-C.ballSpeed*2, Math.min(C.ballSpeed*2, this.ball.vy));
          }

          const remainingBricks = [];
          for (const brick of this.bricks) {
              let hitThisBrick = false;
              const brickHalfWidth = brick.width / 2;
              const brickHalfDepth = brick.depth / 2;
              const dx = this.ball.x - brick.x;
              const dy = this.ball.y - brick.y;
              const combinedHalfWidths = BALL_RADIUS + brickHalfWidth;
              const combinedHalfDepths = BALL_RADIUS + brickHalfDepth;

              if (Math.abs(dx) < combinedHalfWidths && Math.abs(dy) < combinedHalfDepths) {
                  hitThisBrick = true;
                  const overlapX = combinedHalfWidths - Math.abs(dx);
                  const overlapY = combinedHalfDepths - Math.abs(dy);

                  if (overlapX < overlapY && overlapX > BRICK_COLLISION_EPSILON) {
                      if (dx > 0) this.ball.x = brick.x + brickHalfWidth + BALL_RADIUS + BRICK_COLLISION_EPSILON;
                      else this.ball.x = brick.x - brickHalfWidth - BALL_RADIUS - BRICK_COLLISION_EPSILON;
                      this.ball.vx *= -1;
                  } else if (overlapY < overlapX && overlapY > BRICK_COLLISION_EPSILON) {
                      if (dy > 0) this.ball.y = brick.y + brickHalfDepth + BALL_RADIUS + BRICK_COLLISION_EPSILON;
                      else this.ball.y = brick.y - brickHalfDepth - BALL_RADIUS - BRICK_COLLISION_EPSILON;
                      this.ball.vy *= -1;
                  } else {
                      this.ball.x = brick.x + Math.sign(dx) * (brickHalfWidth + BALL_RADIUS + BRICK_COLLISION_EPSILON);
                      this.ball.y = brick.y + Math.sign(dy) * (brickHalfDepth + BALL_RADIUS + BRICK_COLLISION_EPSILON);
                      this.ball.vx *= -1; this.ball.vy *= -1;
                  }
              }
              if (!hitThisBrick) remainingBricks.push(brick);
          }
          this.bricks = remainingBricks;

          const courtHalfWidth = COURT_WIDTH / 2;
          if (this.ball.x < -courtHalfWidth) { this.score[2]++; this.checkWin(2); }
          else if (this.ball.x > courtHalfWidth) { this.score[1]++; this.checkWin(1); }
        }
        this.publish("ui", "state", this.snapshot());
        this.future(MODEL_TICK_RATE_MS).step(); // Faster model tick
      }

      checkWin(scorer) {
        if (this.score[1] >= C.winScore || this.score[2] >= C.winScore) {
          const winner = this.score[1] >= C.winScore ? 1 : 2;
          this.state = `won${winner}`;
          this.score = { 1: 0, 2: 0 };
          this.bricks = this.initBricks();
          this.future(5000).startCountdown();
        } else {
          const servingPlayer = scorer === 1 ? 2 : 1;
          this.lastStarter = servingPlayer;

          const dir = servingPlayer === 1 ? 1 : -1;
          const ballStartX = servingPlayer === 1 ? PADDLE1_INNER_EDGE_X + BALL_RADIUS + 0.05 : PADDLE2_INNER_EDGE_X - BALL_RADIUS - 0.05;
          const ballStartY = this.paddleY[servingPlayer];

          this.ball = { x: ballStartX, y: ballStartY, vx: dir * C.ballSpeed, vy: 0 };
        }
      }

      snapshot() {
        return {
          paddleY: this.paddleY, ball: this.ball, score: this.score,
          state: this.state, countdown: this.countdown, bricks: this.bricks
        };
      }
    }
    PongModel.register("PongModel");

    class PongView extends Multisynq.View {
      constructor(model) {
        super(model);
        this.model = model;
        this.overlay = document.getElementById("overlay");
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        this.camera.position.set(0, COURT_WIDTH * 0.5, COURT_DEPTH * 1.2);
        this.camera.lookAt(0, 0, 0);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(this.renderer.domElement);
        this.resize();
        window.addEventListener("resize", () => this.resize());

        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        const directional = new THREE.DirectionalLight(0xffffff, 0.8);
        directional.position.set(COURT_WIDTH * 0.5, COURT_DEPTH * 1.5, COURT_DEPTH * 0.75);
        directional.castShadow = true;
        directional.shadow.mapSize.width = 1024; directional.shadow.mapSize.height = 1024;
        directional.shadow.camera.near = 0.5; directional.shadow.camera.far = COURT_DEPTH * 3;
        directional.shadow.camera.left = -COURT_WIDTH; directional.shadow.camera.right = COURT_WIDTH;
        directional.shadow.camera.top = COURT_DEPTH; directional.shadow.camera.bottom = -COURT_DEPTH;
        this.scene.add(ambient, directional);

        const court = new THREE.Mesh(
          new THREE.PlaneGeometry(COURT_WIDTH, COURT_DEPTH),
          new THREE.MeshStandardMaterial({ color: 0x3d0f3d, side: THREE.DoubleSide, roughness: 0.9 })
        );
        court.rotation.x = -Math.PI / 2;
        court.receiveShadow = true;
        this.scene.add(court);

        this.paddle1 = new THREE.Mesh(
            new THREE.BoxGeometry(PADDLE_THICKNESS_X, PADDLE_VISUAL_HEIGHT_Y, PADDLE_LENGTH_Z), 
            new THREE.MeshStandardMaterial({ color: 0x0057cc, metalness: 0.4, roughness: 0.5 })
        );
        this.paddle2 = new THREE.Mesh(
            new THREE.BoxGeometry(PADDLE_THICKNESS_X, PADDLE_VISUAL_HEIGHT_Y, PADDLE_LENGTH_Z), 
            new THREE.MeshStandardMaterial({ color: 0xff8800, metalness: 0.4, roughness: 0.5 })
        );
        
        this.paddle1.position.set(PADDLE1_MODEL_CENTER_X, PADDLE_VISUAL_HEIGHT_Y / 2, 0);
        this.paddle2.position.set(PADDLE2_MODEL_CENTER_X, PADDLE_VISUAL_HEIGHT_Y / 2, 0);
        this.paddle1.castShadow = true; this.paddle1.receiveShadow = false;
        this.paddle2.castShadow = true; this.paddle2.receiveShadow = false;

        this.ball = new THREE.Mesh(
            new THREE.SphereGeometry(BALL_RADIUS, 32, 16), 
            new THREE.MeshStandardMaterial({ color: 0xf0f0f0, metalness: 0.5, roughness: 0.3, emissive: 0x111111 })
        );
        this.ball.castShadow = true;
        this.scene.add(this.paddle1, this.paddle2, this.ball);

        this.brickMap = new Map();
        this.subscribe("ui", "state", this.renderState);
        this.publish(this.model.sessionId, "view-join", { viewId: this.viewId });
        this.animate();
        this.handleInput();
      }

      resize() {
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setPixelRatio(window.devicePixelRatio);
      }

      renderState(state) {
        this.paddle1.position.z = state.paddleY[1];
        this.paddle2.position.z = state.paddleY[2];
        this.ball.position.set(state.ball.x, BALL_RADIUS, state.ball.y);

        const seenBrickKeys = new Set();
        state.bricks.forEach(brickData => {
          // Key must use all defining dimensions if they can change per brick,
          // but here width/depth are fixed per brick type, only x,y change.
          const key = `${brickData.x.toFixed(4)},${brickData.y.toFixed(4)}`;
          seenBrickKeys.add(key);

          if (!this.brickMap.has(key)) {
            const brickMesh = new THREE.Mesh(
              // brickData.width and brickData.depth come from the model,
              // ensuring visual matches logical "portrait" orientation.
              new THREE.BoxGeometry(brickData.width, BRICK_VISUAL_HEIGHT_Y, brickData.depth),
              new THREE.MeshStandardMaterial({ color: 0x00bb00, metalness: 0.2, roughness: 0.7, emissive: 0x002200 })
            );
            brickMesh.position.set(brickData.x, BRICK_VISUAL_HEIGHT_Y / 2, brickData.y);
            brickMesh.castShadow = true; brickMesh.receiveShadow = true;
            this.scene.add(brickMesh);
            this.brickMap.set(key, brickMesh);
          }
        });

        for (const [key, mesh] of this.brickMap.entries()) {
          if (!seenBrickKeys.has(key)) {
            this.scene.remove(mesh);
            mesh.geometry.dispose(); mesh.material.dispose();
            this.brickMap.delete(key);
          }
        }

        if (state.state === "waiting") this.overlay.textContent = "Waiting for players...";
        else if (state.state === "countdown") this.overlay.textContent = `Game starts in ${state.countdown}`;
        else if (state.state === "playing") this.overlay.textContent = `${state.score[1]} : ${state.score[2]}`;
        else if (state.state === "won1") this.overlay.textContent = "Player 1 Wins!";
        else if (state.state === "won2") this.overlay.textContent = "Player 2 Wins!";
        else if (state.state === "disconnected") this.overlay.textContent = `Player left. Waiting...`;
      }

      animate() {
        requestAnimationFrame(() => this.animate());
        this.renderer.render(this.scene, this.camera);
      }

      handleInput() {
        const keys = {};
        window.addEventListener("keydown", e => { keys[e.code] = true; });
        window.addEventListener("keyup", e => { keys[e.code] = false; });

        const loop = () => {
          let dy = 0;
          if (keys["ArrowUp"] || keys["KeyW"]) dy += C.paddleSpeed;
          if (keys["ArrowDown"] || keys["KeyS"]) dy -= C.paddleSpeed;
          if (dy !== 0) this.publish(this.model.sessionId, "move", { viewId: this.viewId, dy });
          requestAnimationFrame(loop);
        };
        loop();
      }
    }

    Multisynq.Session.join({
      apiKey: "2atXt6dTbNaKKO83iB4tsYDfmpusH0C6veTYXjy7Om",
      appId: "com.sarcastichedgehog.pongout3d",
      name: Multisynq.App.autoSession(),
      password: Multisynq.App.autoPassword(),
      model: PongModel,
      view: PongView
    });
  </script>
</head>
<body>
  <div id="overlay">Loadingâ€¦</div>
</body>
</html>